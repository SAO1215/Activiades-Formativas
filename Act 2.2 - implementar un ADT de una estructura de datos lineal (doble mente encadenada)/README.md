# Análisis de complejidad temporal (Big-O)

## insertion

**Análisis de complejidad temporal**

Este algoritmo ya no necesita recorrer toda la lista para añadir un elemento al final si no que accede por medio de _tail_, realiza la misma operación de forma independiente a la cantidad de datos por lo que su complejidad es O(1).

## search

**Análisis de complejidad temporal**

Igual que con las listas ligadas simples este algoritmo necesita recorrer cada elemento para evaluar la búsqueda, por eso su complejidad es de O(n).


## update

**Análisis de complejidad temporal**

Para este algoritmo también es necesario recorrer la lista desde el inicio hasta llegar al índice deseado, por lo que su complejidad es de O(n). 

## deleteAt

**Análisis de complejidad temporal**

Éste algoritmo depende de la cantidad de elementos recorrer hasta encontrar el elemento eliminar por lo que su complejidad es de O(n). 
